#!/usr/bin/env python

import argparse
import sqlite3
import gtfs_realtime_pb2
from collections import defaultdict
from operator import itemgetter
from datetime import datetime
from schedules import time_to_string
from box import Box

from twisted.internet import reactor
from twisted.internet.defer import inlineCallbacks
from twisted.web.client import getPage

def get_stop_id_map(cur):
    stop_ids = {}
    results = cur.execute("SELECT stop_id, id FROM stop_ids")
    for stop_id, id in results:
        stop_ids[id] = str(stop_id)
    return stop_ids

@inlineCallbacks
def print_updates(args):
    data = yield getPage("http://developer.mbta.com/lib/gtrtfs/Passages.pb")
    update = gtfs_realtime_pb2.FeedMessage()
    update.ParseFromString(data)

    trip_id_to_delays = defaultdict(list)
    trip_ids = set()
    for entity in update.entity:
        trip_id = str(entity.trip_update.trip.trip_id)
        trip_ids.add(trip_id)
        for stop_time_update in entity.trip_update.stop_time_update:
            # TODO: error-check for lack of arrival.delay
            tup = stop_time_update.stop_sequence, stop_time_update.arrival.delay
            trip_id_to_delays[trip_id].append(tup)
        if trip_id in trip_id_to_delays:
            trip_id_to_delays[trip_id] = sorted(trip_id_to_delays[trip_id], key=itemgetter(0))



    con = sqlite3.connect(args.db)
    cur = con.cursor()
    # injection risk here! SQLite can't handle this many parameters, though
    trip_ids_str = ", ".join(("'%s'" % x) for x in trip_ids)

    stop_id_map = get_stop_id_map(cur)

    query = ('SELECT stop_times.offset, arrivals.blob, '
             'trip_ids.route_id, trip_ids.trip_id '
             'FROM trip_ids '
             'JOIN stop_times ON stop_times.trip_id = trip_ids.id AND trip_ids.trip_id IN (%s) '
             'JOIN arrivals ON arrivals.id = stop_times.arrival_id ') % trip_ids_str
    results = cur.execute(query)

    stop_results = defaultdict(list)

    for offset, arrivals_blob_str, route_id, trip_id in results:
        trip_id = str(trip_id)
        arrivals_blob = Box(arrivals_blob_str)
        arrivals_len = arrivals_blob.read_short()
        for i in xrange(arrivals_len):
            current_delay = 0
            stop_id_int = arrivals_blob.read_short()
            sequence_id = arrivals_blob.read_byte()
            arrival_minutes = arrivals_blob.read_short()

            stop_id = stop_id_map[stop_id_int]
            if trip_id in trip_id_to_delays[trip_id]:
                for stop_sequence, delay in trip_id_to_delays[trip_id]:
                    if stop_sequence > sequence_id:
                        break
                    current_delay = delay

            arrival_seconds = arrival_minutes * 60
            tup = (offset + arrival_seconds, route_id, current_delay, trip_id, sequence_id)
            stop_results[stop_id].append(tup)


    now = datetime.now()
    midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
    now_seconds = (now - midnight).seconds

    if args.stop_id in stop_results:
        lst = stop_results[args.stop_id]
        new_lst = [(seconds, route_id, delay, trip_id, sequence_id)
                   for (seconds, route_id, delay, trip_id, sequence_id) in lst
                   if (seconds + delay) > now_seconds]

        new_lst = sorted(new_lst, key=lambda x: x[0] + x[2])

        if len(new_lst) == 0:
            print("No arrivals for %s" % args.stop_id)
        else:
            for seconds, route_id, delay, trip_id, sequence_id in new_lst:
                print("Next arrival for stop %s (sequence %d) on"
                      " route %s is at %s with delay %d (total %s) on trip %s" % (args.stop_id,
                                                                       sequence_id,
                                                                       route_id,
                                                                       time_to_string(seconds),
                                                                       delay,
                                                                       time_to_string(seconds + delay),
                                                                       trip_id))
    else:
        print("%s is not in any of the trips specified by the SQL query" % args.stop_id)

@inlineCallbacks
def main(args):
    try:
        yield print_updates(args)
    finally:
        reactor.stop()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Print next update for a stop')
    parser.add_argument("db", help="Path to sqlite3 database generated by make_database.py")
    parser.add_argument("stop_id", help="stop id to get results for")
    args = parser.parse_args()
    reactor.callLater(0, lambda: main(args))
    reactor.run()